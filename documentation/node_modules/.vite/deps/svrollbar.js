import {
  fade
} from "./chunk-UYDFXFL5.js";
import "./chunk-6A2TAOKG.js";
import "./chunk-M6MB33T7.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  createEventDispatcher,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  onDestroy,
  onMount,
  safe_not_equal,
  set_style,
  space,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-RVLVW3YK.js";

// node_modules/svrollbar/src/Svrollbar.svelte
var { Error: Error_1 } = globals;
var file = "node_modules\\svrollbar\\src\\Svrollbar.svelte";
function add_css(target) {
  append_styles(target, "svelte-1a8w672", ".v-scrollbar.svelte-1a8w672{position:absolute;top:0;right:0;width:var(--svrollbar-track-width, 10px)}.v-scrollbar.fixed.svelte-1a8w672{position:fixed}.v-track.svelte-1a8w672{position:absolute;top:0;right:0;border-radius:var(--svrollbar-track-radius, initial);width:var(--svrollbar-track-width, 10px);opacity:var(--svrollbar-track-opacity, 1);background:var(--svrollbar-track-background, initial);box-shadow:var(--svrollbar-track-shadow, initial)}.v-thumb.svelte-1a8w672{position:relative;margin:0 auto;border-radius:var(--svrollbar-thumb-radius, 0.25rem);width:var(--svrollbar-thumb-width, 6px);opacity:var(--svrollbar-thumb-opacity, 0.5);background:var(--svrollbar-thumb-background, gray);box-shadow:var(--svrollbar-thumb-shadow, initial)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3Zyb2xsYmFyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyU0UsMkJBQUEsQ0FDRSxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsR0FBQSxDQUFBLENBQU0sQ0FDTixLQUFBLENBQUEsQ0FBUSxDQUNSLEtBQUEsQ0FBQSxJQUFBLHVCQUFBLENBQUEsS0FBQSxDQUNGLENBRUEsWUFBQSxxQkFBQSxDQUNFLFFBQUEsQ0FBQSxLQUNGLENBRUEsdUJBQUEsQ0FDRSxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsR0FBQSxDQUFBLENBQU0sQ0FDTixLQUFBLENBQUEsQ0FBUSxDQUNSLGFBQUEsQ0FBQSxJQUFBLHdCQUFBLENBQUEsUUFBQSxDQUFxRCxDQUNyRCxLQUFBLENBQUEsSUFBQSx1QkFBQSxDQUFBLEtBQUEsQ0FBeUMsQ0FDekMsT0FBQSxDQUFBLElBQUEseUJBQUEsQ0FBQSxFQUFBLENBQTBDLENBQzFDLFVBQUEsQ0FBQSxJQUFBLDRCQUFBLENBQUEsUUFBQSxDQUFzRCxDQUN0RCxVQUFBLENBQUEsSUFBQSx3QkFBQSxDQUFBLFFBQUEsQ0FDRixDQUVBLHVCQUFBLENBQ0UsUUFBQSxDQUFBLFFBQWtCLENBQ2xCLE1BQUEsQ0FBQSxDQUFBLENBQUEsSUFBYyxDQUNkLGFBQUEsQ0FBQSxJQUFBLHdCQUFBLENBQUEsUUFBQSxDQUFxRCxDQUNyRCxLQUFBLENBQUEsSUFBQSx1QkFBQSxDQUFBLElBQUEsQ0FBd0MsQ0FDeEMsT0FBQSxDQUFBLElBQUEseUJBQUEsQ0FBQSxJQUFBLENBQTRDLENBQzVDLFVBQUEsQ0FBQSxJQUFBLDRCQUFBLENBQUEsS0FBQSxDQUFtRCxDQUNuRCxVQUFBLENBQUEsSUFBQSx3QkFBQSxDQUFBLFFBQUEsQ0FDRiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTdnJvbGxiYXIuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let div2;
  let div0;
  let div0_intro;
  let div0_outro;
  let t;
  let div1;
  let div1_intro;
  let div1_outro;
  let current;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      children(div0).forEach(detach_dev);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "v-track svelte-1a8w672");
      set_style(
        div0,
        "height",
        /*trackHeight*/
        ctx[6] + "px"
      );
      add_location(div0, file, 283, 4, 7263);
      attr_dev(div1, "class", "v-thumb svelte-1a8w672");
      set_style(
        div1,
        "height",
        /*thumbHeight*/
        ctx[12] + "px"
      );
      set_style(
        div1,
        "top",
        /*thumbTop*/
        ctx[11] + "px"
      );
      add_location(div1, file, 289, 4, 7398);
      attr_dev(div2, "class", "v-scrollbar svelte-1a8w672");
      set_style(
        div2,
        "height",
        /*trackHeight*/
        ctx[6] + "px"
      );
      set_style(
        div2,
        "margin",
        /*marginTop*/
        ctx[8] + "px " + /*marginRight*/
        ctx[14] + "px " + /*marginBottom*/
        ctx[7] + "px " + /*marginLeft*/
        ctx[13] + "px"
      );
      toggle_class(
        div2,
        "fixed",
        /*windowScrollEnabled*/
        ctx[9]
      );
      add_location(div2, file, 279, 2, 7084);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      ctx[24](div0);
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
      ctx[25](div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*trackHeight*/
      64) {
        set_style(
          div0,
          "height",
          /*trackHeight*/
          ctx2[6] + "px"
        );
      }
      if (!current || dirty[0] & /*thumbHeight*/
      4096) {
        set_style(
          div1,
          "height",
          /*thumbHeight*/
          ctx2[12] + "px"
        );
      }
      if (!current || dirty[0] & /*thumbTop*/
      2048) {
        set_style(
          div1,
          "top",
          /*thumbTop*/
          ctx2[11] + "px"
        );
      }
      if (!current || dirty[0] & /*trackHeight*/
      64) {
        set_style(
          div2,
          "height",
          /*trackHeight*/
          ctx2[6] + "px"
        );
      }
      if (!current || dirty[0] & /*marginTop, marginRight, marginBottom, marginLeft*/
      24960) {
        set_style(
          div2,
          "margin",
          /*marginTop*/
          ctx2[8] + "px " + /*marginRight*/
          ctx2[14] + "px " + /*marginBottom*/
          ctx2[7] + "px " + /*marginLeft*/
          ctx2[13] + "px"
        );
      }
      if (!current || dirty[0] & /*windowScrollEnabled*/
      512) {
        toggle_class(
          div2,
          "fixed",
          /*windowScrollEnabled*/
          ctx2[9]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div0_outro)
          div0_outro.end(1);
        div0_intro = create_in_transition(
          div0,
          /*vTrackIn*/
          ctx[0],
          {}
        );
        div0_intro.start();
      });
      add_render_callback(() => {
        if (!current)
          return;
        if (div1_outro)
          div1_outro.end(1);
        div1_intro = create_in_transition(
          div1,
          /*vThumbIn*/
          ctx[2],
          {}
        );
        div1_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div0_intro)
        div0_intro.invalidate();
      div0_outro = create_out_transition(
        div0,
        /*vTrackOut*/
        ctx[1],
        {}
      );
      if (div1_intro)
        div1_intro.invalidate();
      div1_outro = create_out_transition(
        div1,
        /*vThumbOut*/
        ctx[3],
        {}
      );
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      ctx[24](null);
      if (detaching && div0_outro)
        div0_outro.end();
      ctx[25](null);
      if (detaching && div1_outro)
        div1_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(279:0) {#if visible}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*visible*/
    ctx[10] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*visible*/
        ctx2[10]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*visible*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let teardownViewport;
  let teardownContents;
  let teardownTrack;
  let teardownThumb;
  let marginTop;
  let marginBottom;
  let marginRight;
  let marginLeft;
  let wholeHeight;
  let scrollTop;
  let trackHeight;
  let thumbHeight;
  let thumbTop;
  let scrollable;
  let visible;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Svrollbar", slots, []);
  let { viewport } = $$props;
  let { contents } = $$props;
  let { hideAfter = 1e3 } = $$props;
  let { alwaysVisible = false } = $$props;
  let { initiallyVisible = false } = $$props;
  let { margin = {} } = $$props;
  let { vTrackIn = (node) => fade(node, { duration: 100 }) } = $$props;
  let { vTrackOut = (node) => fade(node, { duration: 300 }) } = $$props;
  let { vThumbIn = (node) => fade(node, { duration: 100 }) } = $$props;
  let { vThumbOut = (node) => fade(node, { duration: 300 }) } = $$props;
  const dispatch = createEventDispatcher();
  let vTrack;
  let vThumb;
  let startTop = 0;
  let startY = 0;
  let timer = 0;
  let windowScrollEnabled = false;
  let interacted = false;
  function setupViewport(viewport2) {
    if (!viewport2)
      return;
    teardownViewport == null ? void 0 : teardownViewport();
    if (typeof window.ResizeObserver === "undefined") {
      throw new Error("window.ResizeObserver is missing.");
    }
    $$invalidate(9, windowScrollEnabled = document.scrollingElement === viewport2);
    const element2 = windowScrollEnabled ? document : viewport2;
    element2.addEventListener("scroll", onScroll, { passive: true });
    const observer = new ResizeObserver((entries) => {
      for (const _entry of entries) {
        $$invalidate(21, wholeHeight = (viewport2 == null ? void 0 : viewport2.scrollHeight) ?? 0);
        $$invalidate(6, trackHeight = (viewport2 == null ? void 0 : viewport2.clientHeight) - (marginTop + marginBottom));
      }
    });
    observer.observe(viewport2);
    return () => {
      element2.removeEventListener("scroll", onScroll);
      observer.unobserve(contents);
      observer.disconnect();
    };
  }
  function setupTrack(track) {
    if (!track)
      return;
    teardownTrack == null ? void 0 : teardownTrack();
    vTrack.addEventListener("mouseenter", onTrackEnter);
    vTrack.addEventListener("mouseleave", onTrackLeave);
    return () => {
      vTrack.removeEventListener("mouseenter", onTrackEnter);
      vTrack.removeEventListener("mouseleave", onTrackLeave);
    };
  }
  function setupThumb(thumb) {
    if (!thumb)
      return;
    teardownThumb == null ? void 0 : teardownThumb();
    vThumb.addEventListener("mousedown", onThumbDown, { passive: true });
    vThumb.addEventListener("touchstart", onThumbDown, { passive: true });
    return () => {
      vThumb.removeEventListener("mousedown", onThumbDown);
      vThumb.removeEventListener("touchstart", onThumbDown);
    };
  }
  function setupContents(contents2) {
    if (!contents2)
      return;
    teardownContents == null ? void 0 : teardownContents();
    if (typeof window.ResizeObserver === "undefined") {
      throw new Error("window.ResizeObserver is missing.");
    }
    const observer = new ResizeObserver((entries) => {
      for (const _entry of entries) {
        $$invalidate(21, wholeHeight = (viewport == null ? void 0 : viewport.scrollHeight) ?? 0);
      }
    });
    observer.observe(contents2);
    return () => {
      observer.unobserve(contents2);
      observer.disconnect();
    };
  }
  function setupTimer() {
    timer = window.setTimeout(
      () => {
        $$invalidate(10, visible = scrollable && (alwaysVisible || initiallyVisible && !interacted) || false);
        dispatch("hide");
      },
      hideAfter
    );
  }
  function clearTimer() {
    if (timer) {
      window.clearTimeout(timer);
      timer = 0;
    }
  }
  function onScroll() {
    if (!scrollable)
      return;
    clearTimer();
    setupTimer();
    $$invalidate(10, visible = alwaysVisible || initiallyVisible && !interacted || true);
    $$invalidate(22, scrollTop = (viewport == null ? void 0 : viewport.scrollTop) ?? 0);
    interacted = true;
    dispatch("show");
  }
  function onTrackEnter() {
    clearTimer();
  }
  function onTrackLeave() {
    clearTimer();
    setupTimer();
  }
  function onThumbDown(event) {
    event.stopPropagation();
    event.preventDefault();
    startTop = viewport.scrollTop;
    startY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
    document.addEventListener("mousemove", onThumbMove);
    document.addEventListener("touchmove", onThumbMove);
    document.addEventListener("mouseup", onThumbUp);
    document.addEventListener("touchend", onThumbUp);
  }
  function onThumbMove(event) {
    event.stopPropagation();
    event.preventDefault();
    const clientY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
    const ratio = wholeHeight / trackHeight;
    $$invalidate(15, viewport.scrollTop = startTop + ratio * (clientY - startY), viewport);
  }
  function onThumbUp(event) {
    event.stopPropagation();
    event.preventDefault();
    startTop = 0;
    startY = 0;
    document.removeEventListener("mousemove", onThumbMove);
    document.removeEventListener("touchmove", onThumbMove);
    document.removeEventListener("mouseup", onThumbUp);
    document.removeEventListener("touchend", onThumbUp);
  }
  onMount(() => {
    $$invalidate(15, viewport = viewport ?? document.scrollingElement);
    $$invalidate(16, contents = contents ?? document.body);
  });
  onDestroy(() => {
    teardownViewport == null ? void 0 : teardownViewport();
    teardownContents == null ? void 0 : teardownContents();
    teardownTrack == null ? void 0 : teardownTrack();
    teardownThumb == null ? void 0 : teardownThumb();
  });
  $$self.$$.on_mount.push(function() {
    if (viewport === void 0 && !("viewport" in $$props || $$self.$$.bound[$$self.$$.props["viewport"]])) {
      console.warn("<Svrollbar> was created without expected prop 'viewport'");
    }
    if (contents === void 0 && !("contents" in $$props || $$self.$$.bound[$$self.$$.props["contents"]])) {
      console.warn("<Svrollbar> was created without expected prop 'contents'");
    }
  });
  const writable_props = [
    "viewport",
    "contents",
    "hideAfter",
    "alwaysVisible",
    "initiallyVisible",
    "margin",
    "vTrackIn",
    "vTrackOut",
    "vThumbIn",
    "vThumbOut"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Svrollbar> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      vTrack = $$value;
      $$invalidate(4, vTrack);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      vThumb = $$value;
      $$invalidate(5, vThumb);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("viewport" in $$props2)
      $$invalidate(15, viewport = $$props2.viewport);
    if ("contents" in $$props2)
      $$invalidate(16, contents = $$props2.contents);
    if ("hideAfter" in $$props2)
      $$invalidate(17, hideAfter = $$props2.hideAfter);
    if ("alwaysVisible" in $$props2)
      $$invalidate(18, alwaysVisible = $$props2.alwaysVisible);
    if ("initiallyVisible" in $$props2)
      $$invalidate(19, initiallyVisible = $$props2.initiallyVisible);
    if ("margin" in $$props2)
      $$invalidate(20, margin = $$props2.margin);
    if ("vTrackIn" in $$props2)
      $$invalidate(0, vTrackIn = $$props2.vTrackIn);
    if ("vTrackOut" in $$props2)
      $$invalidate(1, vTrackOut = $$props2.vTrackOut);
    if ("vThumbIn" in $$props2)
      $$invalidate(2, vThumbIn = $$props2.vThumbIn);
    if ("vThumbOut" in $$props2)
      $$invalidate(3, vThumbOut = $$props2.vThumbOut);
  };
  $$self.$capture_state = () => ({
    fade,
    createEventDispatcher,
    onDestroy,
    onMount,
    viewport,
    contents,
    hideAfter,
    alwaysVisible,
    initiallyVisible,
    margin,
    vTrackIn,
    vTrackOut,
    vThumbIn,
    vThumbOut,
    dispatch,
    vTrack,
    vThumb,
    startTop,
    startY,
    timer,
    windowScrollEnabled,
    interacted,
    setupViewport,
    setupTrack,
    setupThumb,
    setupContents,
    setupTimer,
    clearTimer,
    onScroll,
    onTrackEnter,
    onTrackLeave,
    onThumbDown,
    onThumbMove,
    onThumbUp,
    teardownThumb,
    teardownTrack,
    teardownContents,
    teardownViewport,
    trackHeight,
    wholeHeight,
    scrollTop,
    visible,
    scrollable,
    marginBottom,
    marginTop,
    thumbTop,
    thumbHeight,
    marginLeft,
    marginRight
  });
  $$self.$inject_state = ($$props2) => {
    if ("viewport" in $$props2)
      $$invalidate(15, viewport = $$props2.viewport);
    if ("contents" in $$props2)
      $$invalidate(16, contents = $$props2.contents);
    if ("hideAfter" in $$props2)
      $$invalidate(17, hideAfter = $$props2.hideAfter);
    if ("alwaysVisible" in $$props2)
      $$invalidate(18, alwaysVisible = $$props2.alwaysVisible);
    if ("initiallyVisible" in $$props2)
      $$invalidate(19, initiallyVisible = $$props2.initiallyVisible);
    if ("margin" in $$props2)
      $$invalidate(20, margin = $$props2.margin);
    if ("vTrackIn" in $$props2)
      $$invalidate(0, vTrackIn = $$props2.vTrackIn);
    if ("vTrackOut" in $$props2)
      $$invalidate(1, vTrackOut = $$props2.vTrackOut);
    if ("vThumbIn" in $$props2)
      $$invalidate(2, vThumbIn = $$props2.vThumbIn);
    if ("vThumbOut" in $$props2)
      $$invalidate(3, vThumbOut = $$props2.vThumbOut);
    if ("vTrack" in $$props2)
      $$invalidate(4, vTrack = $$props2.vTrack);
    if ("vThumb" in $$props2)
      $$invalidate(5, vThumb = $$props2.vThumb);
    if ("startTop" in $$props2)
      startTop = $$props2.startTop;
    if ("startY" in $$props2)
      startY = $$props2.startY;
    if ("timer" in $$props2)
      timer = $$props2.timer;
    if ("windowScrollEnabled" in $$props2)
      $$invalidate(9, windowScrollEnabled = $$props2.windowScrollEnabled);
    if ("interacted" in $$props2)
      interacted = $$props2.interacted;
    if ("teardownThumb" in $$props2)
      teardownThumb = $$props2.teardownThumb;
    if ("teardownTrack" in $$props2)
      teardownTrack = $$props2.teardownTrack;
    if ("teardownContents" in $$props2)
      teardownContents = $$props2.teardownContents;
    if ("teardownViewport" in $$props2)
      teardownViewport = $$props2.teardownViewport;
    if ("trackHeight" in $$props2)
      $$invalidate(6, trackHeight = $$props2.trackHeight);
    if ("wholeHeight" in $$props2)
      $$invalidate(21, wholeHeight = $$props2.wholeHeight);
    if ("scrollTop" in $$props2)
      $$invalidate(22, scrollTop = $$props2.scrollTop);
    if ("visible" in $$props2)
      $$invalidate(10, visible = $$props2.visible);
    if ("scrollable" in $$props2)
      $$invalidate(23, scrollable = $$props2.scrollable);
    if ("marginBottom" in $$props2)
      $$invalidate(7, marginBottom = $$props2.marginBottom);
    if ("marginTop" in $$props2)
      $$invalidate(8, marginTop = $$props2.marginTop);
    if ("thumbTop" in $$props2)
      $$invalidate(11, thumbTop = $$props2.thumbTop);
    if ("thumbHeight" in $$props2)
      $$invalidate(12, thumbHeight = $$props2.thumbHeight);
    if ("marginLeft" in $$props2)
      $$invalidate(13, marginLeft = $$props2.marginLeft);
    if ("marginRight" in $$props2)
      $$invalidate(14, marginRight = $$props2.marginRight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*viewport*/
    32768) {
      $:
        teardownViewport = setupViewport(viewport);
    }
    if ($$self.$$.dirty[0] & /*contents*/
    65536) {
      $:
        teardownContents = setupContents(contents);
    }
    if ($$self.$$.dirty[0] & /*vTrack*/
    16) {
      $:
        teardownTrack = setupTrack(vTrack);
    }
    if ($$self.$$.dirty[0] & /*vThumb*/
    32) {
      $:
        teardownThumb = setupThumb(vThumb);
    }
    if ($$self.$$.dirty[0] & /*margin*/
    1048576) {
      $:
        $$invalidate(8, marginTop = margin.top ?? 0);
    }
    if ($$self.$$.dirty[0] & /*margin*/
    1048576) {
      $:
        $$invalidate(7, marginBottom = margin.bottom ?? 0);
    }
    if ($$self.$$.dirty[0] & /*margin*/
    1048576) {
      $:
        $$invalidate(14, marginRight = margin.right ?? 0);
    }
    if ($$self.$$.dirty[0] & /*margin*/
    1048576) {
      $:
        $$invalidate(13, marginLeft = margin.left ?? 0);
    }
    if ($$self.$$.dirty[0] & /*viewport*/
    32768) {
      $:
        $$invalidate(21, wholeHeight = (viewport == null ? void 0 : viewport.scrollHeight) ?? 0);
    }
    if ($$self.$$.dirty[0] & /*viewport*/
    32768) {
      $:
        $$invalidate(22, scrollTop = (viewport == null ? void 0 : viewport.scrollTop) ?? 0);
    }
    if ($$self.$$.dirty[0] & /*viewport, marginTop, marginBottom*/
    33152) {
      $:
        $$invalidate(6, trackHeight = (viewport == null ? void 0 : viewport.clientHeight) ?? 0 - (marginTop + marginBottom));
    }
    if ($$self.$$.dirty[0] & /*wholeHeight, trackHeight*/
    2097216) {
      $:
        $$invalidate(12, thumbHeight = wholeHeight > 0 ? trackHeight / wholeHeight * trackHeight : 0);
    }
    if ($$self.$$.dirty[0] & /*wholeHeight, scrollTop, trackHeight*/
    6291520) {
      $:
        $$invalidate(11, thumbTop = wholeHeight > 0 ? scrollTop / wholeHeight * trackHeight : 0);
    }
    if ($$self.$$.dirty[0] & /*wholeHeight, trackHeight*/
    2097216) {
      $:
        $$invalidate(23, scrollable = wholeHeight > trackHeight);
    }
    if ($$self.$$.dirty[0] & /*scrollable, alwaysVisible, initiallyVisible*/
    9175040) {
      $:
        $$invalidate(10, visible = scrollable && (alwaysVisible || initiallyVisible));
    }
  };
  return [
    vTrackIn,
    vTrackOut,
    vThumbIn,
    vThumbOut,
    vTrack,
    vThumb,
    trackHeight,
    marginBottom,
    marginTop,
    windowScrollEnabled,
    visible,
    thumbTop,
    thumbHeight,
    marginLeft,
    marginRight,
    viewport,
    contents,
    hideAfter,
    alwaysVisible,
    initiallyVisible,
    margin,
    wholeHeight,
    scrollTop,
    scrollable,
    div0_binding,
    div1_binding
  ];
}
var Svrollbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        viewport: 15,
        contents: 16,
        hideAfter: 17,
        alwaysVisible: 18,
        initiallyVisible: 19,
        margin: 20,
        vTrackIn: 0,
        vTrackOut: 1,
        vThumbIn: 2,
        vThumbOut: 3
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svrollbar",
      options,
      id: create_fragment.name
    });
  }
  get viewport() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewport(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contents() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contents(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideAfter() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideAfter(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alwaysVisible() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alwaysVisible(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initiallyVisible() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initiallyVisible(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vTrackIn() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vTrackIn(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vTrackOut() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vTrackOut(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vThumbIn() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vThumbIn(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vThumbOut() {
    throw new Error_1("<Svrollbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vThumbOut(value) {
    throw new Error_1("<Svrollbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svrollbar_default = Svrollbar;

// node_modules/svrollbar/src/Svroller.svelte
var file2 = "node_modules\\svrollbar\\src\\Svroller.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1db7n2f", ".svlr-wrapper.svelte-1db7n2f{position:relative}.svlr-viewport.svelte-1db7n2f{position:relative;overflow:scroll;box-sizing:border-box;-ms-overflow-style:none;scrollbar-width:none}.svlr-viewport.svelte-1db7n2f::-webkit-scrollbar{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3Zyb2xsZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNFRSw0QkFBQSxDQUNFLFFBQUEsQ0FBQSxRQUNGLENBRUEsNkJBQUEsQ0FDRSxRQUFBLENBQUEsUUFBa0IsQ0FDbEIsUUFBQSxDQUFBLE1BQWdCLENBQ2hCLFVBQUEsQ0FBQSxVQUFzQixDQUd0QixrQkFBQSxDQUFBLElBQXdCLENBQ3hCLGVBQUEsQ0FBQSxJQUNGLENBRUEsNkJBQUEsbUJBQUEsQ0FFRSxPQUFBLENBQUEsSUFDRiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTdnJvbGxlci5zdmVsdGUiXX0= */");
}
function create_fragment2(ctx) {
  let div2;
  let div1;
  let div0;
  let t;
  let svrollbar;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  svrollbar = new Svrollbar_default({
    props: {
      viewport: (
        /*viewport*/
        ctx[10]
      ),
      contents: (
        /*contents*/
        ctx[11]
      ),
      hideAfter: (
        /*hideAfter*/
        ctx[2]
      ),
      alwaysVisible: (
        /*alwaysVisible*/
        ctx[3]
      ),
      initiallyVisible: (
        /*initiallyVisible*/
        ctx[4]
      ),
      margin: (
        /*margin*/
        ctx[5]
      ),
      vTrackIn: (
        /*vTrackIn*/
        ctx[6]
      ),
      vTrackOut: (
        /*vTrackOut*/
        ctx[7]
      ),
      vThumbIn: (
        /*vThumbIn*/
        ctx[8]
      ),
      vThumbOut: (
        /*vThumbOut*/
        ctx[9]
      )
    },
    $$inline: true
  });
  svrollbar.$on(
    "show",
    /*show_handler*/
    ctx[16]
  );
  svrollbar.$on(
    "hide",
    /*hide_handler*/
    ctx[17]
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      create_component(svrollbar.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t = claim_space(div2_nodes);
      claim_component(svrollbar.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "svlr-contents");
      add_location(div0, file2, 50, 4, 1400);
      attr_dev(div1, "class", "svlr-viewport svelte-1db7n2f");
      set_style(
        div1,
        "width",
        /*width*/
        ctx[0]
      );
      set_style(
        div1,
        "height",
        /*height*/
        ctx[1]
      );
      add_location(div1, file2, 49, 2, 1306);
      attr_dev(div2, "class", "svlr-wrapper svelte-1db7n2f");
      set_style(
        div2,
        "width",
        /*width*/
        ctx[0]
      );
      set_style(
        div2,
        "height",
        /*height*/
        ctx[1]
      );
      add_location(div2, file2, 48, 0, 1236);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[14](div0);
      ctx[15](div1);
      append_hydration_dev(div2, t);
      mount_component(svrollbar, div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*width*/
      1) {
        set_style(
          div1,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*height*/
      2) {
        set_style(
          div1,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      const svrollbar_changes = {};
      if (dirty & /*viewport*/
      1024)
        svrollbar_changes.viewport = /*viewport*/
        ctx2[10];
      if (dirty & /*contents*/
      2048)
        svrollbar_changes.contents = /*contents*/
        ctx2[11];
      if (dirty & /*hideAfter*/
      4)
        svrollbar_changes.hideAfter = /*hideAfter*/
        ctx2[2];
      if (dirty & /*alwaysVisible*/
      8)
        svrollbar_changes.alwaysVisible = /*alwaysVisible*/
        ctx2[3];
      if (dirty & /*initiallyVisible*/
      16)
        svrollbar_changes.initiallyVisible = /*initiallyVisible*/
        ctx2[4];
      if (dirty & /*margin*/
      32)
        svrollbar_changes.margin = /*margin*/
        ctx2[5];
      if (dirty & /*vTrackIn*/
      64)
        svrollbar_changes.vTrackIn = /*vTrackIn*/
        ctx2[6];
      if (dirty & /*vTrackOut*/
      128)
        svrollbar_changes.vTrackOut = /*vTrackOut*/
        ctx2[7];
      if (dirty & /*vThumbIn*/
      256)
        svrollbar_changes.vThumbIn = /*vThumbIn*/
        ctx2[8];
      if (dirty & /*vThumbOut*/
      512)
        svrollbar_changes.vThumbOut = /*vThumbOut*/
        ctx2[9];
      svrollbar.$set(svrollbar_changes);
      if (!current || dirty & /*width*/
      1) {
        set_style(
          div2,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*height*/
      2) {
        set_style(
          div2,
          "height",
          /*height*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(svrollbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(svrollbar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (default_slot)
        default_slot.d(detaching);
      ctx[14](null);
      ctx[15](null);
      destroy_component(svrollbar);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Svroller", slots, ["default"]);
  let { width = "10rem" } = $$props;
  let { height = "10rem" } = $$props;
  let { hideAfter = 1e3 } = $$props;
  let { alwaysVisible = false } = $$props;
  let { initiallyVisible = false } = $$props;
  let { margin = {} } = $$props;
  let { vTrackIn = (node) => fade(node, { duration: 100 }) } = $$props;
  let { vTrackOut = (node) => fade(node, { duration: 300 }) } = $$props;
  let { vThumbIn = (node) => fade(node, { duration: 100 }) } = $$props;
  let { vThumbOut = (node) => fade(node, { duration: 300 }) } = $$props;
  let viewport;
  let contents;
  const writable_props = [
    "width",
    "height",
    "hideAfter",
    "alwaysVisible",
    "initiallyVisible",
    "margin",
    "vTrackIn",
    "vTrackOut",
    "vThumbIn",
    "vThumbOut"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Svroller> was created with unknown prop '${key}'`);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contents = $$value;
      $$invalidate(11, contents);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewport = $$value;
      $$invalidate(10, viewport);
    });
  }
  function show_handler(event) {
    bubble.call(this, $$self, event);
  }
  function hide_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("hideAfter" in $$props2)
      $$invalidate(2, hideAfter = $$props2.hideAfter);
    if ("alwaysVisible" in $$props2)
      $$invalidate(3, alwaysVisible = $$props2.alwaysVisible);
    if ("initiallyVisible" in $$props2)
      $$invalidate(4, initiallyVisible = $$props2.initiallyVisible);
    if ("margin" in $$props2)
      $$invalidate(5, margin = $$props2.margin);
    if ("vTrackIn" in $$props2)
      $$invalidate(6, vTrackIn = $$props2.vTrackIn);
    if ("vTrackOut" in $$props2)
      $$invalidate(7, vTrackOut = $$props2.vTrackOut);
    if ("vThumbIn" in $$props2)
      $$invalidate(8, vThumbIn = $$props2.vThumbIn);
    if ("vThumbOut" in $$props2)
      $$invalidate(9, vThumbOut = $$props2.vThumbOut);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    Svrollbar: Svrollbar_default,
    width,
    height,
    hideAfter,
    alwaysVisible,
    initiallyVisible,
    margin,
    vTrackIn,
    vTrackOut,
    vThumbIn,
    vThumbOut,
    viewport,
    contents
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("hideAfter" in $$props2)
      $$invalidate(2, hideAfter = $$props2.hideAfter);
    if ("alwaysVisible" in $$props2)
      $$invalidate(3, alwaysVisible = $$props2.alwaysVisible);
    if ("initiallyVisible" in $$props2)
      $$invalidate(4, initiallyVisible = $$props2.initiallyVisible);
    if ("margin" in $$props2)
      $$invalidate(5, margin = $$props2.margin);
    if ("vTrackIn" in $$props2)
      $$invalidate(6, vTrackIn = $$props2.vTrackIn);
    if ("vTrackOut" in $$props2)
      $$invalidate(7, vTrackOut = $$props2.vTrackOut);
    if ("vThumbIn" in $$props2)
      $$invalidate(8, vThumbIn = $$props2.vThumbIn);
    if ("vThumbOut" in $$props2)
      $$invalidate(9, vThumbOut = $$props2.vThumbOut);
    if ("viewport" in $$props2)
      $$invalidate(10, viewport = $$props2.viewport);
    if ("contents" in $$props2)
      $$invalidate(11, contents = $$props2.contents);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    width,
    height,
    hideAfter,
    alwaysVisible,
    initiallyVisible,
    margin,
    vTrackIn,
    vTrackOut,
    vThumbIn,
    vThumbOut,
    viewport,
    contents,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    show_handler,
    hide_handler
  ];
}
var Svroller = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        width: 0,
        height: 1,
        hideAfter: 2,
        alwaysVisible: 3,
        initiallyVisible: 4,
        margin: 5,
        vTrackIn: 6,
        vTrackOut: 7,
        vThumbIn: 8,
        vThumbOut: 9
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svroller",
      options,
      id: create_fragment2.name
    });
  }
  get width() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideAfter() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideAfter(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alwaysVisible() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alwaysVisible(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initiallyVisible() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initiallyVisible(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get margin() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set margin(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vTrackIn() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vTrackIn(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vTrackOut() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vTrackOut(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vThumbIn() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vThumbIn(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vThumbOut() {
    throw new Error("<Svroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vThumbOut(value) {
    throw new Error("<Svroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svroller_default = Svroller;
export {
  Svrollbar_default as Svrollbar,
  Svroller_default as Svroller
};
//# sourceMappingURL=svrollbar.js.map
