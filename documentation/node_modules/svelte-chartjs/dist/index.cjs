'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var internal = require('svelte/internal');
var svelte = require('svelte');
var chart_js = require('chart.js');

const eventPrefix = /^on/;
const events = [];
Object.keys(globalThis).forEach((key)=>{
    if (eventPrefix.test(key)) {
        events.push(key.replace(eventPrefix, ""));
    }
});
function useForwardEvents(getRef) {
    const component = internal.current_component;
    const destructors = [];
    function forward(e) {
        internal.bubble(component, e);
    }
    svelte.onMount(()=>{
        const ref = getRef();
        events.forEach(ref instanceof Element ? (event)=>destructors.push(internal.listen(ref, event, forward)) : (event)=>destructors.push(ref.$on(event, forward)));
    });
    svelte.onDestroy(()=>{
        while(destructors.length){
            destructors.pop()();
        }
    });
}

/**
 * Get dataset from mouse click event
 * @param chart - Chart.js instance
 * @param event - Mouse click event
 * @returns Dataset
 */ function getDatasetAtEvent(chart, event) {
    return chart.getElementsAtEventForMode(event, "dataset", {
        intersect: true
    }, false);
}
/**
 * Get single dataset element from mouse click event
 * @param chart - Chart.js instance
 * @param event - Mouse click event
 * @returns Dataset
 */ function getElementAtEvent(chart, event) {
    return chart.getElementsAtEventForMode(event, "nearest", {
        intersect: true
    }, false);
}
/**
 * Get all dataset elements from mouse click event
 * @param chart - Chart.js instance
 * @param event - Mouse click event
 * @returns Dataset
 */ function getElementsAtEvent(chart, event) {
    return chart.getElementsAtEventForMode(event, "index", {
        intersect: true
    }, false);
}

function create_fragment$8(ctx) {
    let canvas;
    let canvas_levels = [
        /*props*/ ctx[1]
    ];
    let canvas_data = {};
    for(let i = 0; i < canvas_levels.length; i += 1){
        canvas_data = internal.assign(canvas_data, canvas_levels[i]);
    }
    return {
        c () {
            canvas = internal.element("canvas");
            internal.set_attributes(canvas, canvas_data);
        },
        m (target, anchor) {
            internal.insert(target, canvas, anchor);
            /*canvas_binding*/ ctx[8](canvas);
        },
        p (ctx, param) {
            internal.set_attributes(canvas, canvas_data = internal.get_spread_update(canvas_levels, [
                /*props*/ ctx[1]
            ]));
        },
        i: internal.noop,
        o: internal.noop,
        d (detaching) {
            if (detaching) internal.detach(canvas);
            /*canvas_binding*/ ctx[8](null);
        }
    };
}
function clean(props) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let { data , type , options , plugins , children , $$scope , $$slots , ...rest } = props;
    return rest;
}
function instance$8($$self, $$props, $$invalidate) {
    let { type  } = $$props;
    let { data ={
        datasets: []
    }  } = $$props;
    let { options ={}  } = $$props;
    let { plugins =[]  } = $$props;
    let { updateMode =undefined  } = $$props;
    let { chart =null  } = $$props;
    let canvasRef;
    let props = clean($$props);
    svelte.onMount(()=>{
        $$invalidate(2, chart = new chart_js.Chart(canvasRef, {
            type,
            data,
            options,
            plugins
        }));
    });
    svelte.afterUpdate(()=>{
        if (!chart) return;
        $$invalidate(2, chart.data = data, chart);
        $$invalidate(2, chart.options = options, chart);
        chart.update(updateMode);
    });
    svelte.onDestroy(()=>{
        if (chart) chart.destroy();
        $$invalidate(2, chart = null);
    });
    useForwardEvents(()=>canvasRef);
    function canvas_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            canvasRef = $$value;
            $$invalidate(0, canvasRef);
        });
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(9, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
        if ("data" in $$new_props) $$invalidate(4, data = $$new_props.data);
        if ("options" in $$new_props) $$invalidate(5, options = $$new_props.options);
        if ("plugins" in $$new_props) $$invalidate(6, plugins = $$new_props.plugins);
        if ("updateMode" in $$new_props) $$invalidate(7, updateMode = $$new_props.updateMode);
        if ("chart" in $$new_props) $$invalidate(2, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        canvasRef,
        props,
        chart,
        type,
        data,
        options,
        plugins,
        updateMode,
        canvas_binding
    ];
}
class Chart extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$8, create_fragment$8, internal.safe_not_equal, {
            type: 3,
            data: 4,
            options: 5,
            plugins: 6,
            updateMode: 7,
            chart: 2
        });
    }
}

function create_fragment$7(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "line"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance$7($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.LineController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Line extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$7, create_fragment$7, internal.safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$6(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "radar"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance$6($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.RadarController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Radar extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$6, create_fragment$6, internal.safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$5(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "doughnut"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance$5($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.DoughnutController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Doughnut extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$5, create_fragment$5, internal.safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$4(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "pie"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance$4($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.PieController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Pie extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$4, create_fragment$4, internal.safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$3(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "bar"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance$3($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.BarController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Bar extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$3, create_fragment$3, internal.safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$2(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "polarArea"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance$2($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.PolarAreaController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class PolarArea extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$2, create_fragment$2, internal.safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$1(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "bubble"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance$1($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.BubbleController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Bubble extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance$1, create_fragment$1, internal.safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "scatter"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = internal.assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    internal.binding_callbacks.push(()=>internal.bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            internal.create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            internal.mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? internal.get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                internal.get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                internal.add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            internal.transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            internal.transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            internal.destroy_component(chart_1, detaching);
        }
    };
}
function instance($$self, $$props, $$invalidate) {
    chart_js.Chart.register(chart_js.ScatterController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        internal.binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = internal.assign(internal.assign({}, $$props), internal.exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = internal.exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Scatter extends internal.SvelteComponent {
    constructor(options){
        super();
        internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {
            chart: 0
        });
    }
}

/**
 * @deprecated Please use `Chart` name instead.
 * @todo Remove in v3.0.0
 */ const Base = Chart;
/**
 * @deprecated Please use `PolarArea` name instead.
 * @todo Remove in v3.0.0
 */ const Polar = PolarArea;

exports.Bar = Bar;
exports.Base = Base;
exports.Bubble = Bubble;
exports.Chart = Chart;
exports.Doughnut = Doughnut;
exports.Line = Line;
exports.Pie = Pie;
exports.Polar = Polar;
exports.PolarArea = PolarArea;
exports.Radar = Radar;
exports.Scatter = Scatter;
exports.getDatasetAtEvent = getDatasetAtEvent;
exports.getElementAtEvent = getElementAtEvent;
exports.getElementsAtEvent = getElementsAtEvent;
exports.useForwardEvents = useForwardEvents;
//# sourceMappingURL=index.cjs.map
