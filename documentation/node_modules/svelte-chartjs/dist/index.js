import { listen, bubble, current_component, SvelteComponent, init, safe_not_equal, assign, element, set_attributes, insert, get_spread_update, noop, detach, exclude_internal_props, binding_callbacks, bind, create_component, mount_component, get_spread_object, add_flush_callback, transition_in, transition_out, destroy_component } from 'svelte/internal';
import { onMount, onDestroy, afterUpdate } from 'svelte';
import { Chart as Chart$1, LineController, RadarController, DoughnutController, PieController, BarController, PolarAreaController, BubbleController, ScatterController } from 'chart.js';

const eventPrefix = /^on/;
const events = [];
Object.keys(globalThis).forEach((key)=>{
    if (eventPrefix.test(key)) {
        events.push(key.replace(eventPrefix, ""));
    }
});
function useForwardEvents(getRef) {
    const component = current_component;
    const destructors = [];
    function forward(e) {
        bubble(component, e);
    }
    onMount(()=>{
        const ref = getRef();
        events.forEach(ref instanceof Element ? (event)=>destructors.push(listen(ref, event, forward)) : (event)=>destructors.push(ref.$on(event, forward)));
    });
    onDestroy(()=>{
        while(destructors.length){
            destructors.pop()();
        }
    });
}

/**
 * Get dataset from mouse click event
 * @param chart - Chart.js instance
 * @param event - Mouse click event
 * @returns Dataset
 */ function getDatasetAtEvent(chart, event) {
    return chart.getElementsAtEventForMode(event, "dataset", {
        intersect: true
    }, false);
}
/**
 * Get single dataset element from mouse click event
 * @param chart - Chart.js instance
 * @param event - Mouse click event
 * @returns Dataset
 */ function getElementAtEvent(chart, event) {
    return chart.getElementsAtEventForMode(event, "nearest", {
        intersect: true
    }, false);
}
/**
 * Get all dataset elements from mouse click event
 * @param chart - Chart.js instance
 * @param event - Mouse click event
 * @returns Dataset
 */ function getElementsAtEvent(chart, event) {
    return chart.getElementsAtEventForMode(event, "index", {
        intersect: true
    }, false);
}

function create_fragment$8(ctx) {
    let canvas;
    let canvas_levels = [
        /*props*/ ctx[1]
    ];
    let canvas_data = {};
    for(let i = 0; i < canvas_levels.length; i += 1){
        canvas_data = assign(canvas_data, canvas_levels[i]);
    }
    return {
        c () {
            canvas = element("canvas");
            set_attributes(canvas, canvas_data);
        },
        m (target, anchor) {
            insert(target, canvas, anchor);
            /*canvas_binding*/ ctx[8](canvas);
        },
        p (ctx, param) {
            set_attributes(canvas, canvas_data = get_spread_update(canvas_levels, [
                /*props*/ ctx[1]
            ]));
        },
        i: noop,
        o: noop,
        d (detaching) {
            if (detaching) detach(canvas);
            /*canvas_binding*/ ctx[8](null);
        }
    };
}
function clean(props) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let { data , type , options , plugins , children , $$scope , $$slots , ...rest } = props;
    return rest;
}
function instance$8($$self, $$props, $$invalidate) {
    let { type  } = $$props;
    let { data ={
        datasets: []
    }  } = $$props;
    let { options ={}  } = $$props;
    let { plugins =[]  } = $$props;
    let { updateMode =undefined  } = $$props;
    let { chart =null  } = $$props;
    let canvasRef;
    let props = clean($$props);
    onMount(()=>{
        $$invalidate(2, chart = new Chart$1(canvasRef, {
            type,
            data,
            options,
            plugins
        }));
    });
    afterUpdate(()=>{
        if (!chart) return;
        $$invalidate(2, chart.data = data, chart);
        $$invalidate(2, chart.options = options, chart);
        chart.update(updateMode);
    });
    onDestroy(()=>{
        if (chart) chart.destroy();
        $$invalidate(2, chart = null);
    });
    useForwardEvents(()=>canvasRef);
    function canvas_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            canvasRef = $$value;
            $$invalidate(0, canvasRef);
        });
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
        if ("data" in $$new_props) $$invalidate(4, data = $$new_props.data);
        if ("options" in $$new_props) $$invalidate(5, options = $$new_props.options);
        if ("plugins" in $$new_props) $$invalidate(6, plugins = $$new_props.plugins);
        if ("updateMode" in $$new_props) $$invalidate(7, updateMode = $$new_props.updateMode);
        if ("chart" in $$new_props) $$invalidate(2, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        canvasRef,
        props,
        chart,
        type,
        data,
        options,
        plugins,
        updateMode,
        canvas_binding
    ];
}
class Chart extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$8, create_fragment$8, safe_not_equal, {
            type: 3,
            data: 4,
            options: 5,
            plugins: 6,
            updateMode: 7,
            chart: 2
        });
    }
}

function create_fragment$7(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "line"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance$7($$self, $$props, $$invalidate) {
    Chart$1.register(LineController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Line extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$7, create_fragment$7, safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$6(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "radar"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance$6($$self, $$props, $$invalidate) {
    Chart$1.register(RadarController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Radar extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$6, create_fragment$6, safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$5(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "doughnut"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance$5($$self, $$props, $$invalidate) {
    Chart$1.register(DoughnutController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Doughnut extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$5, create_fragment$5, safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$4(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "pie"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance$4($$self, $$props, $$invalidate) {
    Chart$1.register(PieController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Pie extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$4, create_fragment$4, safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$3(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "bar"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance$3($$self, $$props, $$invalidate) {
    Chart$1.register(BarController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Bar extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$3, create_fragment$3, safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$2(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "polarArea"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance$2($$self, $$props, $$invalidate) {
    Chart$1.register(PolarAreaController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class PolarArea extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$2, create_fragment$2, safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment$1(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "bubble"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance$1($$self, $$props, $$invalidate) {
    Chart$1.register(BubbleController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Bubble extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance$1, create_fragment$1, safe_not_equal, {
            chart: 0
        });
    }
}

function create_fragment(ctx) {
    let chart_1;
    let updating_chart;
    let current;
    const chart_1_spread_levels = [
        {
            type: "scatter"
        },
        /*props*/ ctx[2]
    ];
    function chart_1_chart_binding(value) {
        /*chart_1_chart_binding*/ ctx[4](value);
    }
    let chart_1_props = {};
    for(let i = 0; i < chart_1_spread_levels.length; i += 1){
        chart_1_props = assign(chart_1_props, chart_1_spread_levels[i]);
    }
    if (/*chart*/ ctx[0] !== void 0) {
        chart_1_props.chart = /*chart*/ ctx[0];
    }
    chart_1 = new Chart({
        props: chart_1_props
    });
    /*chart_1_binding*/ ctx[3](chart_1);
    binding_callbacks.push(()=>bind(chart_1, "chart", chart_1_chart_binding));
    return {
        c () {
            create_component(chart_1.$$.fragment);
        },
        m (target, anchor) {
            mount_component(chart_1, target, anchor);
            current = true;
        },
        p (ctx, param) {
            let [dirty] = param;
            const chart_1_changes = dirty & /*props*/ 4 ? get_spread_update(chart_1_spread_levels, [
                chart_1_spread_levels[0],
                get_spread_object(/*props*/ ctx[2])
            ]) : {};
            if (!updating_chart && dirty & /*chart*/ 1) {
                updating_chart = true;
                chart_1_changes.chart = /*chart*/ ctx[0];
                add_flush_callback(()=>updating_chart = false);
            }
            chart_1.$set(chart_1_changes);
        },
        i (local) {
            if (current) return;
            transition_in(chart_1.$$.fragment, local);
            current = true;
        },
        o (local) {
            transition_out(chart_1.$$.fragment, local);
            current = false;
        },
        d (detaching) {
            /*chart_1_binding*/ ctx[3](null);
            destroy_component(chart_1, detaching);
        }
    };
}
function instance($$self, $$props, $$invalidate) {
    Chart$1.register(ScatterController);
    let { chart =null  } = $$props;
    let props = $$props;
    let baseChartRef;
    useForwardEvents(()=>baseChartRef);
    function chart_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](()=>{
            baseChartRef = $$value;
            $$invalidate(1, baseChartRef);
        });
    }
    function chart_1_chart_binding(value) {
        chart = value;
        $$invalidate(0, chart);
    }
    $$self.$$set = ($$new_props)=>{
        $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    };
    $$props = exclude_internal_props($$props);
    return [
        chart,
        baseChartRef,
        props,
        chart_1_binding,
        chart_1_chart_binding
    ];
}
class Scatter extends SvelteComponent {
    constructor(options){
        super();
        init(this, options, instance, create_fragment, safe_not_equal, {
            chart: 0
        });
    }
}

/**
 * @deprecated Please use `Chart` name instead.
 * @todo Remove in v3.0.0
 */ const Base = Chart;
/**
 * @deprecated Please use `PolarArea` name instead.
 * @todo Remove in v3.0.0
 */ const Polar = PolarArea;

export { Bar, Base, Bubble, Chart, Doughnut, Line, Pie, Polar, PolarArea, Radar, Scatter, getDatasetAtEvent, getElementAtEvent, getElementsAtEvent, useForwardEvents };
//# sourceMappingURL=index.js.map
